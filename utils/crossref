#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
slub/pvldb -- Bibliometric Analysis of PVLDB
Copyright (c) 2022 SLUB Dresden

This file is part of slub/pvldb.

slub/pvldb is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

slub/pvldb is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with slub/pvldb. If not, see <https://www.gnu.org/licenses/>.
"""
import os
import time
import json
import tqdm
import logging
import requests
from habanero import Crossref
from datetime import timedelta
from timeit import default_timer as timer
from tqdm.contrib.logging import logging_redirect_tqdm

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)
logging.captureWarnings(True)   # due to Crossref.works(warn=True)
logger = logging.getLogger("utils/crossref")


def store_json(obj, path):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(obj, f)


def store_json_pretty(obj, path):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(obj, f, indent=2)


def get_client(mailto=None):
    if mailto is None:
        if "CROSSREF_MAILTO" in os.environ:
            mailto = os.environ["CROSSREF_MAILTO"]
        else:
            logger.warning("Unable to enter Crossref's polite pool!")
    return Crossref(mailto=mailto)


def get_works_from_journal(issn, mailto=None):
    cr = get_client(mailto=mailto)
    works = []
    response = cr.works(filter={"issn": issn},
                        cursor="*", cursor_max=100000, sort="indexed",
                        order="desc", limit=100, progress_bar=True)
    for batch in response:
        if "status" in batch and batch["status"] == "ok":
            for item in batch["message"]["items"]:
                works.append(item)
    return works


def doi_tracker(doi):
    doi_url = "https://doi.org/%s" % doi
    response = requests.get(doi_url, allow_redirects=False)
    if response.status_code == 301 and "Location" in response.headers:
        location = response.headers["Location"]
        if location.startswith("https://doi.org/"):
            return location.replace("https://doi.org/", "")


def get_works(dois, mailto=None):
    cr = get_client(mailto=mailto)
    works = []
    with logging_redirect_tqdm():
        for doi in tqdm.tqdm(dois):
            response = cr.works(ids=[doi], warn=True)
            if isinstance(response, dict) and "status" in response \
                    and response["status"] == "ok":
                works.append(response["message"])
            elif response is None:
                new_doi = doi_tracker(doi)
                if new_doi is not None:
                    msg = "Change of DOI {0} to new DOI {1} detected!".format(
                        doi, new_doi)
                    logger.info(msg)
                    response = cr.works(ids=[new_doi], warn=True)
                    if isinstance(response, dict) and "status" in response \
                            and response["status"] == "ok":
                        works.append(response["message"])
    return works


def get_dois(works):
    dois = [item["DOI"] for item in works]
    dois = list(set(dois))
    dois.sort()
    return dois


def get_prefixes(works):
    prefixes = [item["prefix"] for item in works]
    prefixes = list(set(prefixes))
    prefixes.sort()
    return prefixes


def get_members(works):
    members = [item["member"] for item in works]
    members = list(set(members))
    members.sort()
    return members


def get_issns(works):
    issns = [issn for item in works if "ISSN" in item for issn in item["ISSN"]]
    issns = list(set(issns))
    issns.sort()
    return issns


def get_dois_of_articles(works):
    dois = [item["DOI"] for item in works if item["type"] == "journal-article"]
    dois.sort()
    return dois


def get_dois_of_issues(works):
    dois = [item["DOI"] for item in works if item["type"] == "journal-issue"]
    dois.sort()
    return dois


def get_dois_from_works_references(works):
    mapping = {}
    for item in works:
        doi = item["DOI"]
        mapping[doi] = []
        if "reference" in item:
            for ref in item["reference"]:
                if "DOI" in ref:
                    mapping[doi].append(ref["DOI"])
        else:
            mapping[doi] = None
    mapping = dict(sorted(mapping.items()))
    return mapping


def get_issns_from_works(works):
    mapping = {}
    for item in works:
        doi = item["DOI"]
        issns = list(set(item["ISSN"])) if "ISSN" in item else None
        mapping[doi] = issns
    mapping = dict(sorted(mapping.items()))
    return mapping


def get_issns_stats(works):
    issns = []
    for item in works:
        if "ISSN" in item:
            issns.extend(list(set(item["ISSN"])))
    stats = {}
    for value in list(set(issns)):
        stats[value] = issns.count(value)
    stats = dict(sorted(stats.items(), key=lambda item: item[1], reverse=True))
    return stats


def get_types_per_year(works):
    mapping = {}
    for item in works:
        year = 1970
        if "published" in item:
            if "date-parts" in item["published"]:
                if len(item["published"]["date-parts"]) > 0:
                    if len(item["published"]["date-parts"][0]) > 0:
                        year = item["published"]["date-parts"][0][0]
        if year > 1970:
            if year in mapping:
                mapping[year].append(item["type"])
            else:
                mapping[year] = [item["type"]]
    for year in mapping.keys():
        mapping[year].sort()
    mapping = dict(sorted(mapping.items()))
    return mapping


def citations_url(doi):
    return "https://w3id.org/oc/index/coci/api/v1/citations/%s" % doi


def citations_count_url(doi):
    return "https://w3id.org/oc/index/coci/api/v1/citation-count/%s" % doi


def oc_request(url, repeat=0):
    headers = None
    if "OPENCITATIONS_ACCESS_TOKEN" in os.environ:
        headers = {"Authorization": os.environ["OPENCITATIONS_ACCESS_TOKEN"]}
    else:
        logger.warning("Unable to find access token for OpenCitations!")
    try:
        response = requests.get(url, headers=headers)
    except Exception as e:
        logger.error("Request to URL %s failed!" % url)
        logger.error("Exception of type %s was thrown." % e.__class__.__name__)
        if repeat < 3:
            repeat += 1
            time.sleep(1.1)
            return oc_request(url, repeat=repeat)
        return None
    if response.status_code == 200:
        return response.json()
    else:
        logger.error("Request to URL %s failed!" % url)
        logger.error("HTTP status code was %s." % response.status_code)
        if repeat < 3:
            repeat += 1
            time.sleep(1.1)
            return oc_request(url, repeat=repeat)
        return None


def citations_request(doi):
    url = citations_url(doi)
    return oc_request(url)


def citations_count_request(doi):
    url = citations_count_url(doi)
    response = oc_request(url)
    if isinstance(response, list) and len(response) > 0:
        if isinstance(response[0], dict) and "count" in response[0]:
            return int(response[0]["count"])


def fetch_citations(dois):
    mapping = {}
    for doi in tqdm.tqdm(dois):
        citations = citations_request(doi)
        if isinstance(citations, list):
            mapping[doi] = []
            for citation in citations:
                if isinstance(citation, dict) and "citing" in citation:
                    mapping[doi].append(citation["citing"])
        else:
            mapping[doi] = None
        time.sleep(0.55)
    for doi in mapping.keys():
        if isinstance(mapping[doi], list):
            mapping[doi].sort()
    mapping = dict(sorted(mapping.items()))
    return mapping


def fetch_citations_count(dois):
    mapping = {}
    for doi in tqdm.tqdm(dois):
        citation_count = citations_count_request(doi)
        if isinstance(citation_count, int):
            mapping[doi] = citation_count
        else:
            mapping[doi] = 0
        time.sleep(0.55)
    mapping = dict(sorted(mapping.items()))
    return mapping


def outpath(pattern):
    return "data/crossref_works_filter-issn-2150-8097%s.json" % pattern


def main():
    start = timer()
    logger.info("Fetch works of journal with ISSN 2150-8097!")
    works = get_works_from_journal("2150-8097")
    if not os.path.exists("data"):
        os.makedirs("data")
    store_json(works, outpath("_works"))
    year_types = get_types_per_year(works)
    store_json_pretty(year_types, outpath("_year-types"))
    issn_list = get_issns(works)
    store_json_pretty(issn_list, outpath("_issns"))
    prefix_list = get_prefixes(works)
    store_json_pretty(prefix_list, outpath("_prefixes"))
    member_list = get_members(works)
    store_json_pretty(member_list, outpath("_members"))
    doi_list = get_dois(works)
    store_json_pretty(doi_list, outpath("_dois"))
    issue_doi_list = get_dois_of_issues(works)
    store_json_pretty(issue_doi_list, outpath("_dois-issue"))
    article_doi_list = get_dois_of_articles(works)
    store_json_pretty(article_doi_list, outpath("_dois-article"))
    reference_dois = get_dois_from_works_references(works)
    store_json_pretty(reference_dois, outpath("_reference"))
    reference_count = {doi: len(reference_dois[doi] or [])
                       for doi in reference_dois}
    reference_count = dict(sorted(reference_count.items(),
                                  key=lambda item: item[1], reverse=True))
    store_json_pretty(reference_count, outpath("_count-reference"))
    reference_doi_list = list(set([ref_doi for doi in reference_dois
                                   for ref_doi in reference_dois[doi] or []]))
    reference_doi_list.sort()
    store_json_pretty(reference_doi_list, outpath("_dois-reference"))
    logger.info("Fetch works cited in works of journal with ISSN 2150-8097!")
    reference_works = get_works(reference_doi_list)
    store_json(reference_works, outpath("_works-reference"))
    reference_issns = get_issns_from_works(reference_works)
    store_json_pretty(reference_issns, outpath("_works-reference_issns"))
    reference_issn_stats = get_issns_stats(reference_works)
    store_json_pretty(reference_issn_stats,
                      outpath("_count-issns-reference"))
    reference_issn_list = get_issns(reference_works)
    store_json_pretty(reference_issn_list, outpath("_issns-reference"))
    reference_year_types = get_types_per_year(reference_works)
    store_json_pretty(reference_year_types,
                      outpath("_year-types-reference"))
    citation_dois = fetch_citations(doi_list)
    store_json_pretty(citation_dois, outpath("_citation"))
    citation_count = {doi: len(citation_dois[doi] or [])
                      for doi in citation_dois}
    citation_count = dict(sorted(citation_count.items(),
                                 key=lambda item: item[1], reverse=True))
    store_json_pretty(citation_count, outpath("_count-citation"))
    citation_doi_list = list(set([cit_doi for doi in citation_dois
                                  for cit_doi in citation_dois[doi] or []]))
    citation_doi_list.sort()
    store_json_pretty(citation_doi_list, outpath("_dois-citation"))
    logger.info("Fetch works citing works of journal with ISSN 2150-8097!")
    citation_works = get_works(citation_doi_list)
    store_json(citation_works, outpath("_works-citation"))
    citation_issns = get_issns_from_works(citation_works)
    store_json_pretty(citation_issns, outpath("_works-citation_issns"))
    citation_issn_stats = get_issns_stats(citation_works)
    store_json_pretty(citation_issn_stats,
                      outpath("_count-issns-citation"))
    citation_issn_list = get_issns(citation_works)
    store_json_pretty(citation_issn_list, outpath("_issns-citation"))
    citation_year_types = get_types_per_year(citation_works)
    store_json_pretty(citation_year_types,
                      outpath("_year-types-citation"))
    end = timer()
    logger.info("All done!")
    logger.info("Took {0} (h:m:s)".format(timedelta(seconds=end - start)))


if __name__ == '__main__':
    main()
